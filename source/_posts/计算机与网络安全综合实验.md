---
title: 计算机与网络安全综合实验
categories:
  - 想要毕业
  - 网络与协议安全
description: 实验报告
abbrlink: ebacd475
date: 2021-05-13 08:16:50
tags:
cover:
katex: truer
---

## 实验一 古典密码算法的实现

### 实验内容

1. 根据实验原理部分对替代密码算法的介绍,实现以下替代密码算法的加密和解密操作，并完成明密文之间的频率统计分析。
   1. 凯撒密码
   2. 维吉尼亚密码 Vigenere
   3. PlayFair密码
   4. 一次一密 One-time Pad
2. 根据实验原理部分对置换密码算法的介绍，自己创建明文信息，并选择一个密钥，编写置换密码算法的实现程序，实现加密和解密操作。

### 实验目的

通过编程实现**替代密码**算法和**置换密码**算法，加深对古典密码体制的了解，为深入学习密码学奠定基础。

### 实验原理

古典密码算法在历史上曾被广泛使用，大都比较简单，使用手工和机械操作来实现加密和解密。它的主要应用对象是文字信息，利用密码算法实现文字信息的加密和解密。下面介绍两种常见的具有代表性的古典密码算法，以帮助读者对古典密码算法建立一个初步的印象。

#### 替代密码

替代密码算法的原理是使用替代法进行加密，就是将明文中的字符用其它字符替代后形成密文。例如明文字母 a,b,c,d 用 D,E,F,G 做对应替换后形成密文。

替代密码包括多种类型，如单表替代密码、多明码替代密码、多字母替代密码、多表替代密码。下面我们介绍一种典型的单表替代密码：恺撒(caesar)密码，又叫循环移位密码。它的加密方法就是将明文中的每个字母用此字符在字母表中后面第 $k$ 个字母替代。它的加密过程可以表示为下面的函数:

$$E(m)=(m+k)\ mod\ n$$

其中：$m$ 为明文字母在字母表中的位置数；$n$ 为字母表中的字母个数；$k$ 为密钥；$E(m)$ 为密文字母在字母表中对应的位置数。

#### 置换密码

置换密码算法的原理是不改变明文字符，只将字符在明文中的排列顺序改变，从而实现明文信息的加密。置换密码有时又称为换位密码。

矩阵换位法是实现置换密码的一种常用方法，它将明文中的字母按照给的顺序安排在一个矩阵中，然后根据密钥提供的顺序重新组合矩阵中字母，从而形成密文。例如明文为 attack begins at five，密钥为 cipher，将明文按照每行 6 列的形式排在矩阵中，形成如下形式：
$$
\left[
\begin{matrix} 
a&t&t&a&c&k\\
b&e&g&i&n&s\\
a&t&f&i&v&e
\end{matrix}
\right]
$$
根据密钥 cipher 中各字母在字母表中出现的先后顺序，给定一个置换：
$$
\left[
\begin{matrix} 
1&2&3&4&5&6\\
1&5&4&2&3&6
\end{matrix}
\right]
$$
根据上面的置换，原有矩阵中的字母排列为以下形式：
$$
\left[
\begin{matrix} 
a&c&a&t&t&k\\
b&n&i&e&g&s\\
a&v&i&t&f&e
\end{matrix}
\right]
$$
从而得到密文：acattkbniegsavitfe

其解密的过程是根据密钥的字母数作为列数，将密文按照列、行的顺序写出，再根据由密钥给出的矩阵置换产生新的矩阵，从而恢复明文。

### 实验步骤

#### 凯撒密码 Caser

```python
def encrypt(message, key):
    tmp_text = ''
    tmp_key = key.upper()
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) + (ord(tmp_key)-ord('A')))% 26)
    return tmp_text

def decrypt(message, key):
    tmp_text = ''
    tmp_key = key.upper()
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) - (ord(tmp_key)-ord('A')))% 26)
    return tmp_text

def main():
    message = 'Common sense is not so common.'
    key = 'P'

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 凯撒密码 Caser")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 凯撒密码 Caser
加密前的文本是: Common sense is not so common.
加密密钥是: P
加密后的文本是: Rdbbdc htcht xh cdi hd rdbbdc.
解密后的文本是: Common sense is not so common.
```

#### 维吉尼亚密码 Vigenere

```python
def encrypt(message, key):
    tmp_text = ''
    keylen = len(key)
    tmp_key = key.upper()
    i = 0
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) + (ord(tmp_key[i])-ord('A')))% 26)
            i += 1
            if i == keylen: i = 0
    return tmp_text

def decrypt(message, key):
    tmp_text = ''
    keylen = len(key)
    tmp_key = key.upper()
    i = 0
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) - (ord(tmp_key[i])-ord('A')))% 26)
            i += 1
            if i == keylen: i = 0
    return tmp_text

def main():
    message = 'Common sense is not so common.'
    key = 'PIZZA'

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 维吉尼亚密码 Vigenere")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 维吉尼亚密码 Vigenere
加密前的文本是: Common sense is not so common.
加密密钥是: PIZZA
加密后的文本是: Rwlloc admst qr moi an bobunm.
解密后的文本是: Common sense is not so common.
```

#### 普莱费尔密码 playfair

```python
import numpy as np

def gen_keylist(key):
    base = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'
    tmp_key = key.upper().replace(' ','').replace('J','I')
    keylist = ''
    for c in tmp_key:
        if c not in keylist: keylist += c
    for c in base:
        if c not in keylist: keylist += c
    
    return(keylist)

def gen_keytab(keylist):
    keytab = np.zeros((5,5),dtype=str)
    for i in range(25):
        j = i % 5
        k = i // 5
        keytab[j][k] = keylist[i]

    return(keytab)

def gen_keydic(keylist):
    keydic = dict()
    for i in range(25):
        keydic[keylist[i]] = [i % 5, i // 5]
    
    return(keydic)

def encrypt(message, key):
    tmp_text = ''
    for c in message.upper():
        if c.isalpha():
            if c == 'J': tmp_text += 'I'
            elif c == tmp_text[-1:]:
                tmp_text += 'X'
                tmp_text += c
            else: tmp_text += c
    if len(tmp_text) % 2 == 1: tmp_text += 'X'

    keylist = gen_keylist(key)
    keytab = gen_keytab(keylist)
    keydic = gen_keydic(keylist)
    # print(tmp_text)
    # print(keytab)
    tmpstr = ''
    for i in range(len(tmp_text) // 2):
        j = i * 2
        a = tmp_text[j]
        b = tmp_text[j+1]
        # print(a,b)
        # print(keydic[a],keydic[b])
        if keydic[a][0] == keydic[b][0]:
            tmp = keydic[a][0]
            tmpa = keytab[tmp][(keydic[a][1]+1)%5]
            tmpb = keytab[tmp][(keydic[b][1]+1)%5]
        elif keydic[a][1] == keydic[b][1]:
            tmp = keydic[a][1]
            tmpa = keytab[(keydic[a][0]+1)%5][tmp]
            tmpb = keytab[(keydic[b][0]+1)%5][tmp]
        else:
            tmpa = keytab[keydic[a][0]][keydic[b][1]]
            tmpb = keytab[keydic[b][0]][keydic[a][1]]
        tmpstr += tmpa
        tmpstr += tmpb
    # print(tmpstr)
    encrypted_text = ''    
    for i in range(len(tmpstr)):
        encrypted_text += tmpstr[i]
        if i % 5 == 4: encrypted_text += ' '

    return(encrypted_text)

def decrypt(message, key):
    tmp_text = message.replace(' ','')

    keylist = gen_keylist(key)
    keytab = gen_keytab(keylist)
    keydic = gen_keydic(keylist)

    tmpstr = ''
    for i in range(len(tmp_text)//2):
        j = i * 2
        a = tmp_text[j]
        b = tmp_text[j+1]
        if keydic[a][0] == keydic[b][0]:
            tmp = keydic[a][0]
            tmpa = keytab[tmp][(keydic[a][1]-1)%5]
            tmpb = keytab[tmp][(keydic[b][1]-1)%5]
        elif keydic[a][1] == keydic[b][1]:
            tmp = keydic[a][1]
            tmpa = keytab[(keydic[a][0]-1)%5][tmp]
            tmpb = keytab[(keydic[b][0]-1)%5][tmp]
        else:
            tmpa = keytab[keydic[a][0]][keydic[b][1]]
            tmpb = keytab[keydic[b][0]][keydic[a][1]]
        tmpstr += tmpa
        tmpstr += tmpb
    
    decrypted_text = tmpstr[0]
    for i in range(1, len(tmpstr)-1):
        if (tmpstr[i] == 'X') and (tmpstr[i-1] == tmpstr[i+1]):
            continue
        else: decrypted_text += tmpstr[i]
    if tmpstr[-1:] != 'X': decrypted_text += tmpstr[-1:]

    return(decrypted_text)

def try_english(message):
    with open('dictionary.txt','r') as f:
        wordlist = f.readlines()
    for i in range(len(wordlist)):
        wordlist[i] = wordlist[i].rstrip('\n')
    
    decrypted_text = ''
    tmpword = ''
    for c in message:
        tmpword += c
        if tmpword in wordlist:
            decrypted_text += tmpword.lower()
            decrypted_text += ' '
            tmpword = ''
    decrypted_text += tmpword.lower()
    
    return(decrypted_text)

def main():
    message = 'Common sense js not so common.'
    key = 'Keep it Simple and Stupid.'

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 普莱费尔密码 playfair 按列填充密钥，横向替换密文，I替代J")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)
    print("尝试解读:", try_english(decrypted_text))
    # 暂时解决不了

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 普莱费尔密码 playfair 按列填充密钥，横向替换密文，I替代J
加密前的文本是: Common sense js not so common.
加密密钥是: Keep it Simple and Stupid.
加密后的文本是: QBVAG ASMMT KMAKQ ANKBQ AGAVA Q
解密后的文本是: COMMONSENSEISNOTSOCOMMON
尝试解读: common sense isnotsocommon
```

#### 一次一密 One-time Pad

```python
def encrypt(message, key):
    list = [chr(ord(a)^ord(b)) for a,b in zip(message,key)]

    return(bytes(''.join(list),encoding='utf-8'))

def decrypt(message, key):
    tmp_message = message.decode()
    list = [chr(ord(a)^ord(b)) for a,b in zip(tmp_message,key)]
    
    return(''.join(list))

def main():
    message = 'Common sense is not so common.'
    key = message[::-1]

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 一次一密 One-time Pad")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 一次一密 One-time Pad
加密前的文本是: Common sense is not so common.
加密密钥是: .nommoc os ton si esnes nommoC
加密后的文本是: b'm\x01\x02\x00\x02\x01CS\n\x1dS\x11O\x07SS\x07O\x11S\x1d\nSC\x01\x02\x00\x02\x01m'
解密后的文本是: Common sense is not so common.
```



### 实验总结







## 实验三 无线局域网安全实验

### 实验内容

完成无线局域网 WPA2-PSK 安全机制的配置以及 WPA2 的身份鉴别机制的应用。

### 实验目的

1. 验证 AP 和终端实现 WEP 安全机制相关参数的配置过程
2. 验证 AP 和终端实现 WPA2-PSK 安全机制相关参数的配置过程
3. 验证 终端 与 AP 之间建立关联的过程
4. 验证属于不同 BSS 的终端之间的通信过程
5. 验证 AAA 服务器的配置过程
6. 验证注册用户通过接入终端实现网络资源访问的过程

### 实验原理

随着移动终端的普及，无线局域网日益成为适用最广泛的局域网。无线局域网的无线传输特性，要求 AP 和 无线路由器必须对需要与其建立关联的终端进行身份鉴别，同时需要加密终端与 AP 和无线路由器之间传输的数据。因此，正确配置无线局域网的安全机制是安全使用无线局域网的前提。

#### WEP 和 WPA2-PSK 实验

![image-20210520092740982](https://img.foopi.top/postpic/image-20210520092740982.webp)

AP1 选择 WEP 安全机制，配置共享密钥。终端A 和 终端B 同样选择 WEP 安全机制，配置与 AP1 相同的共享密钥。AP2 选择 WPA2-PSK 安全机制，配置用于导出 PSK 的密钥。终端E 和 终端F 同样选择 WPA2-PSK 安全机制，配置与 AP2 相同的用于导出 PSK 的密钥。

Packet Tracer 中终端支持 Windows 的自动私有IP地址分配(Automatic Private IP Addressing, APIPA)机制，如果终端启动自动获得IP地址方式，但在发送DHCP请求消息后一直没有接受到DHCP服务器发送的响应消息，则Windows自动在微软保留的私有网络地址 169.254.0.0/255.255.0.0 中为终端随机选择一个有效IP地址。因此，如果扩展服务集中的所有终端均采用这一IP地址分配方式，则无须为终端配置IP地址就可实现终端之间的通信过程，安装无线网卡的终端的默认获取IP地址方式就是DHCP方式。

#### WPA2 实验

<img src="https://img.foopi.top/postpic/image-20210520125803728.webp" alt="image-20210520125803728" style="zoom:50%;" />

每一个用户完成注册后，获得唯一的身份标识信息：用户名和口令，所有注册用户的身份标识信息统一记录在AAA服务器中。每一台无线路由器中需要配置AAA服务器的IP地址和该无线路由器与AAA服务器之间的共享密钥。当无线路由器需要鉴别用户身份时，无线路由器只将用户提供的身份标识信息转发给AAA服务器，由AAA服务器完成身份鉴别过程，并将鉴别结果回送给无线路由器。

### 实验步骤

#### WEP 和 WPA2-PSK 实验

1. 根据如图5.1所示的无线局域网结构放置和连接设备：

   ![image-20210520100752011](https://img.foopi.top/postpic/image-20210520100752011.webp)

2. 默认情况下，笔记本计算机安装以太网卡，为了接入无线局域网，需要将笔记本计算机的以太网卡换成无线网卡。单击 Laptop0，弹出 Laptop0 配置界面，选择 Physical 配置选项，弹出安装物理模块界面。关掉主机电源，将原来安装在主机上的以太网卡拖放到左边模块栏中，然后将模块 WPC300N 拖放到主机原来安装以太网卡的位置。模块 WPC300N 是支持 2.4G 频段的 802.11、802.11b 和 802.11g 标准的无线网卡。重新打开主机电源。用同样的方式，将其他笔记本计算机的以太网卡换成无线网卡。

3. 完成 Access Point0 “Config”--“Port1” 操作过程。Authentication 中勾选 WEP，Encryption Type 选择 40/64-Bits(10 Hex digits)，在 WEP Key 框中输入由10个十六进制数字组成的40位密钥。在 SSID 框中输入制定的 SSID。Port Status 勾选 On。

   <img src="https://img.foopi.top/postpic/image-20210520101659620.webp" alt="image-20210520101659620" style="zoom: 50%;" />

4. 完成 Laptop0 “Config”--“Wireless0” 操作过程。在 Authentication 栏中选择 WEP，Encryption Type 选择 40/64-Bits(10 Hex digits)，在 WEP Key 框中输入与 Access Point0 相同的由10个十六进制数字组成的40位密钥。在 SSID 框中输入与 Access Point0 相同的 SSID。Port Status 勾选 On。以同样的方式完成 Laptop1 与实现 WEP 安全机制相关参数的配置过程。完成 Access Point0、Laptop0 和 Laptop1 与实现 WEP 安全机制相关参数的配置后，Laptop0 和 Laptop1 与 Access Point0 之间成功建立关联。

   <img src="https://img.foopi.top/postpic/image-20210520105846522.webp" alt="image-20210520105846522" style="zoom:50%;" />

5. 终端一旦选择 DHCP 方式，启动自动私有IP地址分配(APIPA)机制，在没有 DHCP服务器 为其配置网络信息的前提下，有终端自动在私有网络地址 169.254.0.0/255.255.0.0 中随机选择一个有效IP地址作为其IP地址。DHCP方式是安装无线网卡的笔记本计算机默认的获取网络信息方式。

6. 完成 Access Point1 “Config”--“Port1” 操作过程。Authentication 中勾选 WPA2-PSK，Encryption Type 选择 AES，导出 PSK 的 Pass Phrase 框中输入由8～63个字符组成的密钥。在 SSID 框中输入制定的 SSID。Port Status 勾选 On。

   <img src="https://img.foopi.top/postpic/image-20210520110700101.webp" alt="image-20210520110700101" style="zoom:50%;" />

7. 完成 Laptop2 “Config”--“Wireless0” 操作过程。在 Authentication 栏中选择 WPA2-PSK，Encryption Type 选择 AES，在导出 PSK 的 Pass Phrase 框中输入与 Access Point1 相同的由8～63个字符组成的密钥。在 SSID 框中输入与 Access Point1 相同的 SSID。Port Status 勾选 On。以同样的方式完成 Laptop3 与实现 WPA2-PSK 安全机制相关参数的配置过程。完成 Access Point1、Laptop2 和 Laptop3 与实现 WEP 安全机制相关参数的配置后，Laptop2 和 Laptop3 与 Access Point1 之间成功建立关联。

   <img src="https://img.foopi.top/postpic/image-20210520110739168.webp" alt="image-20210520110739168" style="zoom:50%;" />

8.  完成 PC0 “Desktop”--“IP Configuration” 操作过程。选择 DHCP，由 PC0 自动选择的IP地址如图所示。以同样的方式完成 PC1 获取网络信息过程。

   <img src="https://img.foopi.top/postpic/image-20210520111126682.webp" alt="image-20210520111126682" style="zoom:50%;" />

9. 通过简单报文工具启动各个终端之间的 ICMP 报文传输过程，验证各个终端之间的连通性。

   <img src="https://img.foopi.top/postpic/image-20210520113354089.webp" alt="image-20210520113354089" style="zoom:50%;" />

   Laptop0的IP地址信息:

   <img src="https://img.foopi.top/postpic/image-20210520113457302.webp" alt="image-20210520113457302" style="zoom:50%;" />

   ping Laptop1:

   <img src="https://img.foopi.top/postpic/image-20210520113807468.webp" alt="image-20210520113807468" style="zoom:50%;" />

   ping Laptop3:

   <img src="https://img.foopi.top/postpic/image-20210520113926688.webp" alt="image-20210520113926688" style="zoom:50%;" />

   ping PC1:

   <img src="https://img.foopi.top/postpic/image-20210520114039489.webp" alt="image-20210520114039489" style="zoom:50%;" />

#### WPA2 实验

1. 无线局域网中，终端与无线路由器之间没有物理连接过程，但终端必须位于无线路由器的有效通信范围内，因此，无线局域网需要在物理工作区中确定终端与无线路由器之间的距离。选择物理工作区，单击 NAVIGATION 菜单，选择 Home City，单击 Jump to Selected Location 按钮，物理工作区中出现家园城市界面。

   <img src="https://img.foopi.top/postpic/image-20210520131302882.webp" alt="image-20210520131302882" style="zoom:50%;" />

2. 在设备类型选择框中选择 Wireless Devices，在设备选择框中选择无线路由器(WRT300N)。将无线路由器拖放到物理工作区中，可以看到无线路由器的有效通信范围。将笔记本计算机放置在无线路由器的有效通信范围内，无线设备选择无线路由器而不是 AP 的原因是 Packet Tracer 中只有无线路由器支持 WPA2。在物理工作区中根据如图5.10所示的无线局域网结构放置和连接设备。

   <img src="https://img.foopi.top/postpic/image-20210520133425074.webp" alt="image-20210520133425074" style="zoom:50%;" />

3. 切换到逻辑工作区。

   <img src="https://img.foopi.top/postpic/image-20210520133524128.webp" alt="image-20210520133524128" style="zoom:50%;" />

4. 完成无线路由器 Router1 “Config”--“Wireless” 操作过程。在 Authentication 栏中选择 WPA2。在 RADIUS Server Settings 栏下的 IP Address 框中输入 RADIUS服务器 的IP地址，这里是 192.1.2.7。 在 Shared Secret 框中输入该无线路由器与 AAA服务器 之间的共享密钥，这里是 router1。Encryption Type 选择 AES。在 SSID 框中输入指定的 SSID，这里是 123456。以同样的方式完成无线路由器 Router2 无线接口配置过程。

   <img src="https://img.foopi.top/postpic/image-20210520134120206.webp" alt="image-20210520134120206" style="zoom:50%;" />

5. 完成无线路由器 Router1 “Config”--“Internet” 操作过程。在 IP Configuration 栏中选择 Static IP 地址配置方式。在 Default Gateway 框中输入路由器 Router 连接交换机 Switch0 的接口的IP地址，这里是192.1.1.254。在 IP Address 框中输入无线路由器 Router1 Internet 接口的IP地址，这里是 192.1.1.1。在 Subnet Mask 框中输入无线路由器 Router1 Internet 接口的子网掩码，这里是 255.255.255.0。以同样的方式完成无线路由器 Router2 Internet 接口配置过程。

   <img src="https://img.foopi.top/postpic/image-20210520135005012.webp" alt="image-20210520135005012" style="zoom:50%;" />

6. 完成 AAA Server “Desktop”--“IP Configuration” 操作过程。配置的IP地址必须与无线路由器 Router1、Router2 中配置的 RADIUS 服务器地址相同。

   <img src="https://img.foopi.top/postpic/image-20210520143830735.webp" alt="image-20210520143830735" style="zoom:50%;" />

7. 完成 AAA Server ”Services“--”AAA“ 操作过程。首先建立与路由器 Router1 和 Router2 之间的关联。建立关联过程中，在 Client Name 框中输入设备标识符，如无线路由器 Router2 的设备标识符 Router2。在客户端 Client IP 框中输入无线路由器 Router1 和 Router2 向 AAA 服务器发送 RADIUS 报文时，用于输出 RADIUS 报文的接口的IP地址，即 Router1 和 Router2 Internet 接口的IP地址，如无线路由器 Router2 Internet 接口的IP地址 192.1.1.2。在 Secret 框中输入 Router1 和 Router2 与 AAA 服务器之间的共享密钥，如 Router2 与 AAA 服务器之间的共享密钥 router2。

   然后定义所有的注册用户。定义注册用户过程中，在 Username 框中输入注册用户的用户名，如 aaa3。在 Password 框中输入注册用户的口令，如 bbb3。

   <img src="https://img.foopi.top/postpic/image-20210520140455116.webp" alt="image-20210520140455116" style="zoom:50%;" />

8. 配置路由器 Router

   <img src="https://img.foopi.top/postpic/image-20210520141939831.webp" alt="image-20210520141939831" style="zoom:50%;" />

   <img src="https://img.foopi.top/postpic/image-20210520142011895.webp" alt="image-20210520142011895" style="zoom:50%;" />

9. 完成 Laptop0 "Config"--"Wireless0" 操作过程。

   <img src="https://img.foopi.top/postpic/image-20210520143951470.webp" alt="image-20210520143951470" style="zoom:50%;" />

   <img src="https://img.foopi.top/postpic/image-20210520144308161.webp" alt="image-20210520144308161" style="zoom:50%;" />

10. 通过简单报文工具，验证 Laptop* 与 Web服务器之间的连通性。

    ![image-20210520145058291](https://img.foopi.top/postpic/image-20210520145058291.webp)

### 实验总结





## 实验四 点对点IP隧道实验

### 实验内容

完成点对点IP隧道网络搭建，利用IP隧道技术完成一对用户通过公共网络进行安全通信的过程。

### 实验目的

1. 掌握VPN设计过程
2. 掌握点对点IP隧道配置过程
3. 掌握公共网络路由建立过程
4. 掌握内部网络路由建立过程
5. 验证公共网络隧道两端的传输路径的建立过程
6. 验证基于隧道实现的内部子网之间的IP分组传输过程

### 实验原理

<img src="https://img.foopi.top/postpic/image-20210520150008317.webp" alt="image-20210520150008317" style="zoom:50%;" />

VPN 物理结构如图(a)所示。路由器 R4、R5 和 R6 构成公共网络，边缘路由器 R1、R2 和 R3 一端连接内部子网，另一端连接公共网络。由于公共网络无法传输以私有IP地址为源和目的IP地址的IP分组，因此，由公共网络互连的多个分配私有IP地址的内部子网之间无法直接进行通信。为了实现被公共网络分隔的多个内部子网之间的通信过程，需要建立以边缘路由器连接公共网络的接口为两端的点对点IP隧道，并为点对点IP隧道的两端分配私有IP地址。因此将(a)所示的物理结构转变为(b)所示的逻辑结构:

<img src="https://img.foopi.top/postpic/image-20210520150836542.webp" alt="image-20210520150836542" style="zoom:50%;" />

点对点IP隧道成为互连边缘路由器的虚拟点对点链路，边缘路由器之间能够通过点对点IP隧道直接传输以私有IP地址为源和目的IP地址的IP分组。点对点IP隧道经过公共网络，因此需要通过隧道技术完成以私有IP地址为源和目的IP地址的IP分组经过公共网络传输的过程。

### 实验步骤

1. 根据图(a)所示网络结构放置和连接设备。
2. 
3. 
4. 
5. 

### 实验总结







## 实验

### 实验内容

### 实验目的

### 实验原理

### 实验步骤

### 实验总结