---
title: 计算机与网络安全综合实验
categories:
  - 想要毕业
  - 网络与协议安全
description: 实验报告
abbrlink: ebacd475
date: 2021-05-13 08:16:50
tags:
cover:
katex: truer
---

## 实验一 古典密码算法的实现

### 实验内容

1. 根据实验原理部分对替代密码算法的介绍,实现以下替代密码算法的加密和解密操作，并完成明密文之间的频率统计分析。
   1. 凯撒密码
   2. 维吉尼亚密码 Vigenere
   3. PlayFair密码
   4. 一次一密 One-time Pad
2. 根据实验原理部分对置换密码算法的介绍，自己创建明文信息，并选择一个密钥，编写置换密码算法的实现程序，实现加密和解密操作。

### 实验目的

通过编程实现**替代密码**算法和**置换密码**算法，加深对古典密码体制的了解，为深入学习密码学奠定基础。

### 实验原理

古典密码算法在历史上曾被广泛使用，大都比较简单，使用手工和机械操作来实现加密和解密。它的主要应用对象是文字信息，利用密码算法实现文字信息的加密和解密。下面介绍两种常见的具有代表性的古典密码算法，以帮助读者对古典密码算法建立一个初步的印象。

#### 替代密码

替代密码算法的原理是使用替代法进行加密，就是将明文中的字符用其它字符替代后形成密文。例如明文字母 a,b,c,d 用 D,E,F,G 做对应替换后形成密文。

替代密码包括多种类型，如单表替代密码、多明码替代密码、多字母替代密码、多表替代密码。下面我们介绍一种典型的单表替代密码：恺撒(caesar)密码，又叫循环移位密码。它的加密方法就是将明文中的每个字母用此字符在字母表中后面第 $k$ 个字母替代。它的加密过程可以表示为下面的函数:

$$E(m)=(m+k)\ mod\ n$$

其中：$m$ 为明文字母在字母表中的位置数；$n$ 为字母表中的字母个数；$k$ 为密钥；$E(m)$ 为密文字母在字母表中对应的位置数。

#### 置换密码

置换密码算法的原理是不改变明文字符，只将字符在明文中的排列顺序改变，从而实现明文信息的加密。置换密码有时又称为换位密码。

矩阵换位法是实现置换密码的一种常用方法，它将明文中的字母按照给的顺序安排在一个矩阵中，然后根据密钥提供的顺序重新组合矩阵中字母，从而形成密文。例如明文为 attack begins at five，密钥为 cipher，将明文按照每行 6 列的形式排在矩阵中，形成如下形式：
$$
\left[
\begin{matrix} 
a&t&t&a&c&k\\
b&e&g&i&n&s\\
a&t&f&i&v&e
\end{matrix}
\right]
$$
根据密钥 cipher 中各字母在字母表中出现的先后顺序，给定一个置换：
$$
\left[
\begin{matrix} 
1&2&3&4&5&6\\
1&5&4&2&3&6
\end{matrix}
\right]
$$
根据上面的置换，原有矩阵中的字母排列为以下形式：
$$
\left[
\begin{matrix} 
a&c&a&t&t&k\\
b&n&i&e&g&s\\
a&v&i&t&f&e
\end{matrix}
\right]
$$
从而得到密文：acattkbniegsavitfe

其解密的过程是根据密钥的字母数作为列数，将密文按照列、行的顺序写出，再根据由密钥给出的矩阵置换产生新的矩阵，从而恢复明文。

### 实验步骤

#### 凯撒密码 Caser

```python
def encrypt(message, key):
    tmp_text = ''
    tmp_key = key.upper()
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) + (ord(tmp_key)-ord('A')))% 26)
    return tmp_text

def decrypt(message, key):
    tmp_text = ''
    tmp_key = key.upper()
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) - (ord(tmp_key)-ord('A')))% 26)
    return tmp_text

def main():
    message = 'Common sense is not so common.'
    key = 'P'

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 凯撒密码 Caser")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 凯撒密码 Caser
加密前的文本是: Common sense is not so common.
加密密钥是: P
加密后的文本是: Rdbbdc htcht xh cdi hd rdbbdc.
解密后的文本是: Common sense is not so common.
```

#### 维吉尼亚密码 Vigenere

```python
def encrypt(message, key):
    tmp_text = ''
    keylen = len(key)
    tmp_key = key.upper()
    i = 0
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) + (ord(tmp_key[i])-ord('A')))% 26)
            i += 1
            if i == keylen: i = 0
    return tmp_text

def decrypt(message, key):
    tmp_text = ''
    keylen = len(key)
    tmp_key = key.upper()
    i = 0
    for c in message:
        if not c.isalpha():
            tmp_text += c
        else:
            if c.isupper(): a = 'A'
            else: a = 'a'
            tmp_text += chr(ord(a)+((ord(c)-ord(a)) - (ord(tmp_key[i])-ord('A')))% 26)
            i += 1
            if i == keylen: i = 0
    return tmp_text

def main():
    message = 'Common sense is not so common.'
    key = 'PIZZA'

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 维吉尼亚密码 Vigenere")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 维吉尼亚密码 Vigenere
加密前的文本是: Common sense is not so common.
加密密钥是: PIZZA
加密后的文本是: Rwlloc admst qr moi an bobunm.
解密后的文本是: Common sense is not so common.
```

#### 普莱费尔密码 playfair

```python
import numpy as np

def gen_keylist(key):
    base = 'ABCDEFGHIKLMNOPQRSTUVWXYZ'
    tmp_key = key.upper().replace(' ','').replace('J','I')
    keylist = ''
    for c in tmp_key:
        if c not in keylist: keylist += c
    for c in base:
        if c not in keylist: keylist += c
    
    return(keylist)

def gen_keytab(keylist):
    keytab = np.zeros((5,5),dtype=str)
    for i in range(25):
        j = i % 5
        k = i // 5
        keytab[j][k] = keylist[i]

    return(keytab)

def gen_keydic(keylist):
    keydic = dict()
    for i in range(25):
        keydic[keylist[i]] = [i % 5, i // 5]
    
    return(keydic)

def encrypt(message, key):
    tmp_text = ''
    for c in message.upper():
        if c.isalpha():
            if c == 'J': tmp_text += 'I'
            elif c == tmp_text[-1:]:
                tmp_text += 'X'
                tmp_text += c
            else: tmp_text += c
    if len(tmp_text) % 2 == 1: tmp_text += 'X'

    keylist = gen_keylist(key)
    keytab = gen_keytab(keylist)
    keydic = gen_keydic(keylist)
    # print(tmp_text)
    # print(keytab)
    tmpstr = ''
    for i in range(len(tmp_text) // 2):
        j = i * 2
        a = tmp_text[j]
        b = tmp_text[j+1]
        # print(a,b)
        # print(keydic[a],keydic[b])
        if keydic[a][0] == keydic[b][0]:
            tmp = keydic[a][0]
            tmpa = keytab[tmp][(keydic[a][1]+1)%5]
            tmpb = keytab[tmp][(keydic[b][1]+1)%5]
        elif keydic[a][1] == keydic[b][1]:
            tmp = keydic[a][1]
            tmpa = keytab[(keydic[a][0]+1)%5][tmp]
            tmpb = keytab[(keydic[b][0]+1)%5][tmp]
        else:
            tmpa = keytab[keydic[a][0]][keydic[b][1]]
            tmpb = keytab[keydic[b][0]][keydic[a][1]]
        tmpstr += tmpa
        tmpstr += tmpb
    # print(tmpstr)
    encrypted_text = ''    
    for i in range(len(tmpstr)):
        encrypted_text += tmpstr[i]
        if i % 5 == 4: encrypted_text += ' '

    return(encrypted_text)

def decrypt(message, key):
    tmp_text = message.replace(' ','')

    keylist = gen_keylist(key)
    keytab = gen_keytab(keylist)
    keydic = gen_keydic(keylist)

    tmpstr = ''
    for i in range(len(tmp_text)//2):
        j = i * 2
        a = tmp_text[j]
        b = tmp_text[j+1]
        if keydic[a][0] == keydic[b][0]:
            tmp = keydic[a][0]
            tmpa = keytab[tmp][(keydic[a][1]-1)%5]
            tmpb = keytab[tmp][(keydic[b][1]-1)%5]
        elif keydic[a][1] == keydic[b][1]:
            tmp = keydic[a][1]
            tmpa = keytab[(keydic[a][0]-1)%5][tmp]
            tmpb = keytab[(keydic[b][0]-1)%5][tmp]
        else:
            tmpa = keytab[keydic[a][0]][keydic[b][1]]
            tmpb = keytab[keydic[b][0]][keydic[a][1]]
        tmpstr += tmpa
        tmpstr += tmpb
    
    decrypted_text = tmpstr[0]
    for i in range(1, len(tmpstr)-1):
        if (tmpstr[i] == 'X') and (tmpstr[i-1] == tmpstr[i+1]):
            continue
        else: decrypted_text += tmpstr[i]
    if tmpstr[-1:] != 'X': decrypted_text += tmpstr[-1:]

    return(decrypted_text)

def try_english(message):
    with open('dictionary.txt','r') as f:
        wordlist = f.readlines()
    for i in range(len(wordlist)):
        wordlist[i] = wordlist[i].rstrip('\n')
    
    decrypted_text = ''
    tmpword = ''
    for c in message:
        tmpword += c
        if tmpword in wordlist:
            decrypted_text += tmpword.lower()
            decrypted_text += ' '
            tmpword = ''
    decrypted_text += tmpword.lower()
    
    return(decrypted_text)

def main():
    message = 'Common sense js not so common.'
    key = 'Keep it Simple and Stupid.'

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 普莱费尔密码 playfair 按列填充密钥，横向替换密文，I替代J")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)
    print("尝试解读:", try_english(decrypted_text))
    # 暂时解决不了

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 普莱费尔密码 playfair 按列填充密钥，横向替换密文，I替代J
加密前的文本是: Common sense js not so common.
加密密钥是: Keep it Simple and Stupid.
加密后的文本是: QBVAG ASMMT KMAKQ ANKBQ AGAVA Q
解密后的文本是: COMMONSENSEISNOTSOCOMMON
尝试解读: common sense isnotsocommon
```

#### 一次一密 One-time Pad

```python
def encrypt(message, key):
    list = [chr(ord(a)^ord(b)) for a,b in zip(message,key)]

    return(bytes(''.join(list),encoding='utf-8'))

def decrypt(message, key):
    tmp_message = message.decode()
    list = [chr(ord(a)^ord(b)) for a,b in zip(tmp_message,key)]
    
    return(''.join(list))

def main():
    message = 'Common sense is not so common.'
    key = message[::-1]

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 一次一密 One-time Pad")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 一次一密 One-time Pad
加密前的文本是: Common sense is not so common.
加密密钥是: .nommoc os ton si esnes nommoC
加密后的文本是: b'm\x01\x02\x00\x02\x01CS\n\x1dS\x11O\x07SS\x07O\x11S\x1d\nSC\x01\x02\x00\x02\x01m'
解密后的文本是: Common sense is not so common.
```

#### 置换密码

```python
import numpy as np

def gen_keylist(key):
    base = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    keydic = dict()
    tmp = 0
    for c in key.upper():
        if c not in keydic.keys():
            tmp += 1
            keydic[c] = tmp
    keylist = []
    for c in base:
        if c in keydic.keys():
            keylist.append(keydic[c])

    return(keylist)

def encrypt(message, key):
    keylist = gen_keylist(key)
    tmp_text = ''
    for c in message:
        if c.isalpha(): tmp_text += c
    length = len(tmp_text)
    col = len(keylist)
    row = (length-1) // col + 1
    mess_tab = np.zeros((row, col), dtype=str)
    for i in range(length):
        mess_tab[i//col][i%col] = tmp_text[i]
    tmp_tab = np.zeros((row, col), dtype=str)
    for i in range(col):
        for j in range(row):
            tmp_tab[j][i] = mess_tab[j][keylist[i]-1]
    encrypted_text = ''
    for i in range(row):
        for j in range(col):
            encrypted_text += tmp_tab[i][j]

    return(encrypted_text)


def decrypt(message, key):
    keylist = gen_keylist(key)
    tmp_text = message
    length = len(tmp_text)
    col = len(keylist)
    row = (length-1) // col + 1
    mess_tab = np.zeros((row, col), dtype=str)
    for i in range(length):
        mess_tab[i//col][i%col] = tmp_text[i]
    tmp_tab = np.zeros((row, col), dtype=str)
    for i in range(col):
        for j in range(row):
            tmp_tab[j][keylist[i]-1] = mess_tab[j][i]
    decrypted_text = ''
    for i in range(row):
        for j in range(col):
            decrypted_text += tmp_tab[i][j]

    return(decrypted_text)

def main():
    message = 'Attack begins at five.'
    key = 'cipher'

    cipher_text = encrypt(message, key)
    decrypted_text = decrypt(cipher_text, key)

    print("加解密方式: 置换密码")
    print("加密前的文本是:", message)
    print("加密密钥是:", key)
    print("加密后的文本是:", cipher_text)
    print("解密后的文本是:", decrypted_text)

if __name__ == '__main__':
    main()
```

```shell
加解密方式: 置换密码
加密前的文本是: Attack begins at five.
加密密钥是: cipher
加密后的文本是: Acattkbniegsavitfe
解密后的文本是: Attackbeginsatfive
```

### 实验总结

关于字母频率分析，额外进行了kasiski试验实现对维吉尼亚密码的唯密文攻击:

```python
import math
import vigenere

def pre_treatment(message):
    # 提取字母
    tmp_text = ''
    for c in message:
        if c.isalpha():
            tmp_text += c
    # 全员大写
    return(tmp_text.upper())

def find_repeat_sequences_spacings(message):
    # 预处理字符串    
    tmp_text = pre_treatment(message)
    # 生成重复序列间隔字典
    dic = dict()
    # 查找3-5位字母长度的重复序列
    for strlen in range(3,6):
        for i in range(0,len(tmp_text)-2*strlen+1):
            tmp_str = tmp_text[i:i+strlen]
            tmp_count = tmp_text.count(tmp_str)
            if tmp_count > 1:
                if tmp_str not in dic.keys():
                    last = tmp_text.find(tmp_str)
                    find_list = [last]
                    for j in range(1,tmp_count):
                        now = tmp_text.find(tmp_str,last+strlen)
                        find_list.append(now)
                        last = now
                    spacing_list = []
                    listlen = len(find_list)
                    for j in range(0,listlen-1):
                        for k in range(j+1,listlen):
                            spacing_list.append(find_list[k]-find_list[j])
                    dic[tmp_str] = spacing_list
        
    return(dic)

def get_useful_factors(num):
    factors_list = []
    for i in range(2,math.isqrt(num)+1):
        if num % i == 0:
            factors_list.append(i)
            j = num//i
            if i != j:
                factors_list.append(j)
    factors_list.sort()
    
    return(factors_list)

def get_possible_keylen(message):
    tmp_dic = find_repeat_sequences_spacings(message)
    dic_fac =  dict()
    for i in tmp_dic:
        for j in tmp_dic[i]:
            tmp_fac = get_useful_factors(j)
            for k in tmp_fac:
                if k not in dic_fac:
                    dic_fac[k] = 1
                else:
                    dic_fac[k] += 1
    list_fac = []
    for i in sorted(dic_fac.items(), key=lambda x:(-x[1],x[0])):
#        print(i)
        list_fac.append(i[0])
    
    return(list_fac)

def get_nth_subkeys_letters(n, key_length, message):
    # 预处理字符串    
    tmp_text = pre_treatment(message)
    tmp_str = ''
    i = 0
    for c in tmp_text:
        if i % key_length == n-1:
            tmp_str += c
        i += 1

    return(tmp_str)

def freq_match_score(message):
    ETAOIN = 'ETAOINSHRDLCUMWFGYPBVKJXQZ'
    match_score = 0
    tmp_text = pre_treatment(message)
    # 初始化计数字典并计数
#    base = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
#    上面这行注释绝妙，无意间解决了ETAOIN排序问题
    dic_letter_freq = dict()
    for c in ETAOIN:
        dic_letter_freq[c] = 0
    for c in tmp_text:
        dic_letter_freq[c] += 1
    # 生成频数字母列表字典
    dic_freq_letter = dict()
    for i in dic_letter_freq.items():
        if i[1] not in dic_freq_letter.keys():
            dic_freq_letter[i[1]] = [i[0]]
        else:
            dic_freq_letter[i[1]].append(i[0])
    # 频数字典排序生成匹配串
    freq_string = ''
    for f in sorted(dic_freq_letter.items(),key=lambda x:(-x[0])):
        for c in f[1]:
            freq_string += c
    # 累计频率匹配分数
    for c in freq_string[:6]:
        if c in ETAOIN[:6]:
            match_score += 1
    for c in freq_string[-6:]:
        if c in ETAOIN[-6:]:
            match_score += 1

    return(match_score)

# 另一种字母频率分析
def freq_score(message):
    tmp_text = pre_treatment(message)
    dic_freq = dict()
    dic_freq = {'A': 8.167, 'B': 1.492, 'C': 2.782, 'D': 4.253,
                'E': 12.702, 'F': 2.228, 'G': 2.015, 'H': 6.094,
                'I': 6.966, 'J': 0.153, 'K': 0.772, 'L': 4.025,
                'M': 2.406, 'N': 6.749, 'O': 7.507, 'P': 1.929,
                'Q': 0.095, 'R': 5.987, 'S': 6.327, 'T': 9.056,
                'U': 2.758, 'V': 0.978, 'W': 2.360, 'X': 0.150,
                'Y': 1.974, 'Z': 0.074}
    count = 0
    sum = 0
    for c in tmp_text:
        count += 1
        sum += dic_freq[c]
    return(sum/count)

def is_english(message, word_percentage=20, letter_percentage=85):
    # 加载字典生成字典列表
    with open('dictionary.txt', 'r') as f:
        wordlist = f.readlines()
    for i in range(0,len(wordlist)):
        wordlist[i] = wordlist[i].rstrip('\n')
    # 英文检测
    tmp_text = message.upper()
    tmp_wordlist = []
    tmp_word = ''
    sum_letter = 0
    sum_word = 0
    for c in tmp_text:
        if c.isalpha():
            tmp_word += c
            sum_letter += 1
        else:
            if c.isspace():
                sum_letter += 1
            tmp_wordlist.append(tmp_word)
            tmp_word = ''
    for w in tmp_wordlist:
        if w in wordlist:
            sum_word += 1
    freq_letter = sum_letter / len(tmp_text) * 100
    freq_word = sum_word / len(tmp_wordlist) * 100
#    print(freq_letter)
#    print(freq_word)
    if (freq_letter >= letter_percentage) and (freq_word >= word_percentage):
        return(True)
    else:
        return(False)

def test():
    ciphertext = 'Ppqca xqvekg ybnkmazu ybngbal jon i tszm jyim. Vrag voht vrau c tksg. Ddwuo xitlazu vavv raz c vkb qp iwpou.'
    
    print(find_repeat_sequences_spacings(ciphertext))
    print(get_useful_factors(24))

    print(get_possible_keylen(ciphertext))

    for i in range(1, 5):
        print(get_nth_subkeys_letters(i, 4, ciphertext))
    
    message = 'I rc ascwuiluhnviwuetnh,osgaa ice tipeeeee slnatsfietgi tittynecenisl. e fo f fnc isltn sn o a yrs sd onisli ,l erglei trhfmwfrogotn,l stcofiit.aea wesn,lnc ee w,l eIh eeehoer ros iol er snh nl oahsts ilasvih tvfeh rtira id thatnie.im ei-dlmf i thszonsisehroe, aiehcdsanahiec gv gyedsB affcahiecesd d lee onsdihsoc nin cethiTitx eRneahgin r e teom fbiotd n ntacscwevhtdhnhpiwru'
    print(freq_match_score(message))

def kasiski(message):
    flag = False
    # 尝试最有可能的5种密钥长度
    for keylen in get_possible_keylen(message)[:5]:
        print('keylen = ', keylen)
        dic_key = dict()
        for i in range(0, keylen):
            base_string = get_nth_subkeys_letters(i+1, keylen, message)
            dic_score = dict()
            top_guess = 3   # 每位密钥测试3个最有可能的字母
            for j in range(0, 26):
                tmp_string = ''
                for c in base_string:
                    tmp_string += chr(ord('A')+(ord(c)-ord('A')-j) % 26)
                    dic_score[chr(ord('A')+j)] = freq_score(tmp_string)
            dic_key[i] = ''
            tmp_count = 0
            for k in sorted(dic_score.items(),key=lambda x:-x[1]):
                tmp_count += 1
                dic_key[i] += k[0]
                print(i,tmp_count, k)
                if tmp_count == top_guess:
                    break
        print(dic_key)
        # 参考二进制思想生成可能密钥
        for i in range(0, top_guess**keylen):
            tmp_key = ''
            if i == 0:
                for j in range(0, keylen):
                    tmp_key += dic_key[j][0]
            else:
                tmp = i
                dkey = -1
                while tmp > 0:
                    dkey += 1
                    dvalue = tmp % top_guess
                    tmp_key += dic_key[dkey][dvalue]
                    tmp //= top_guess
                for j in range(dkey+1, keylen):
                    tmp_key += dic_key[j][0]
            # 尝试解密
            decrypted_text = vigenere.decrypt(message, tmp_key)
            if is_english(decrypted_text):
                print(decrypted_text)
                print('key =',tmp_key)
                flag = True
                break
        if flag:
            break

def main():
    message = '' 
    with open('ciphertext_vigenere.txt','r') as f:
        for i in f.readlines():
            message += i

    print(message)

    kasiski(message)

if __name__ == '__main__':
#    test()
    main()
```

```python
Adiz Avtzqeci Tmzubb wsa m Pmilqev halpqavtakuoi, lgouqdaf, kdmktsvmztsl, izr xoexghzr kkusitaaf. Vz wsa twbhdg ubalmmzhdad qz hce vmhsgohuqbo ox kaakulmd gxiwvos, krgdurdny i rcmmstugvtawz ca tzm ocicwxfg jf "stscmilpy" oid "uwydptsbuci" wabt hce Lcdwig eiovdnw. Bgfdny qe kddwtk qjnkqpsmev ba pz tzm roohwz at xoexghzr kkusicw izr vrlqrwxist uboedtuuznum. Pimifo Icmlv Emf DI, Lcdwig owdyzd xwd hce Ywhsmnemzh Xovm mby Cqxtsm Supacg (GUKE) oo Bdmfqclwg Bomk, Tzuhvif'a ocyetzqofifo ositjm. Rcm a lqys ce oie vzav wr Vpt 8, lpq gzclqab mekxabnittq tjr Ymdavn fihog cjgbhvnstkgds. Zm psqikmp o iuejqf jf lmoviiicqg aoj jdsvkavs Uzreiz qdpzmdg, dnutgrdny bts helpar jf lpq pjmtm, mb zlwkffjmwktoiiuix avczqzs ohsb ocplv nuby swbfwigk naf ohw Mzwbms umqcifm. Mtoej bts raj pq kjrcmp oo tzm Zooigvmz Khqauqvl Dincmalwdm, rhwzq vz cjmmhzd gvq ca tzm rwmsl lqgdgfa rcm a kbafzd-hzaumae kaakulmd, hce SKQ. Wi 1948 Tmzubb jgqzsy Msf Zsrmsv'e Qjmhcfwig Dincmalwdm vt Eizqcekbqf Pnadqfnilg, ivzrw pq onsaafsy if bts yenmxckmwvf ca tzm Yoiczmehzr uwydptwze oid tmoohe avfsmekbqr dn eifvzmsbuqvl tqazjgq. Pq kmolm m dvpwz ab ohw ktshiuix pvsaa at hojxtcbefmewn, afl bfzdakfsy okkuzgalqzu xhwuuqvl jmmqoigve gpcz ie hce Tmxcpsgd-Lvvbgbubnkq zqoxtawz, kciup isme xqdgo otaqfqev qz hce 1960k. Bgfdny'a tchokmjivlabk fzsmtfsy if i ofdmavmz krgaqqptawz wi 1952, wzmz vjmgaqlpad iohn wwzq goidt uzgeyix wi tzm Gbdtwl Wwigvwy. Vz aukqdoev bdsvtemzh rilp rshadm tcmmgvqg (xhwuuqvl uiehmalqab) vs sv mzoejvmhdvw ba dmikwz. Hpravs rdev qz 1954, xpsl whsm tow iszkk jqtjrw pug 42id tqdhcdsg, rfjm ugmbddw xawnofqzu. Vn avcizsl lqhzreqzsy tzif vds vmmhc wsa eidcalq; vds ewfvzr svp gjmw wfvzrk jqzdenmp vds vmmhc wsa mqxivmzhvl. Gv 10 Esktwunsm 2009, fgtxcrifo mb Dnlmdbzt uiydviyv, Nfdtaat Dmiem Ywiikbqf Bojlab Wrgez avdw iz cafakuog pmjxwx ahwxcby gv nscadn at ohw Jdwoikp scqejvysit xwd "hce sxboglavs kvy zm ion tjmmhzd." Sa at Haq 2012 i bfdvsbq azmtmd'g widt ion bwnafz tzm Tcpsw wr Zjrva ivdcz eaigd yzmbo Tmzubb a kbmhptgzk dvrvwz wa efiohzd.
keylen =  3
0 1 ('A', 5.125612431444254)
0 2 ('M', 5.112906764168203)
0 3 ('Z', 4.292806215722134)
1 1 ('O', 5.333315018315032)
1 2 ('S', 5.273826007326018)
1 3 ('D', 4.486067765567781)
2 1 ('I', 5.830117216117233)
2 2 ('V', 5.392289377289392)
2 3 ('E', 4.267117216117228)
{0: 'AMZ', 1: 'OSD', 2: 'IVE'}
keylen =  2
0 1 ('I', 4.810197560975626)
0 2 ('O', 4.562274390243913)
0 3 ('A', 4.415186585365871)
1 1 ('M', 4.557256410256414)
1 2 ('V', 4.542681318681341)
1 3 ('I', 4.338537240537258)
{0: 'IOA', 1: 'MVI'}
keylen =  6
0 1 ('A', 6.367591240875909)
0 2 ('P', 5.041430656934308)
0 3 ('E', 4.885160583941612)
1 1 ('S', 6.245344322344322)
1 2 ('H', 4.7055934065934135)
1 3 ('W', 4.369351648351649)
2 1 ('I', 6.8673223443223455)
2 2 ('T', 4.873608058608065)
2 3 ('E', 4.650586080586077)
3 1 ('M', 6.306934065934067)
3 2 ('Z', 4.561073260073258)
3 3 ('Q', 4.492465201465203)
4 1 ('O', 6.575586080586089)
4 2 ('D', 4.607542124542126)
4 3 ('Z', 4.570794871794874)
5 1 ('V', 6.368021978021977)
5 2 ('I', 4.7929120879120966)
5 3 ('Z', 4.592890109890112)
{0: 'APE', 1: 'SHW', 2: 'ITE', 3: 'MZQ', 4: 'ODZ', 5: 'VIZ'}
Alan Mathison Turing was a British mathematician, logician, cryptanalyst, and computer scientist. He was highly influential in the development of computer science, providing a formalisation of the concepts of "algorithm" and "computation" with the Turing machine. Turing is widely considered to be the father of computer science and artificial intelligence. During World War II, Turing worked for the Government Code and Cypher School (GCCS) at Bletchley Park, Britain's codebreaking centre. For a time he was head of Hut 8, the section responsible for German naval cryptanalysis. He devised a number of techniques for breaking German ciphers, including the method of the bombe, an electromechanical machine that could find settings for the Enigma machine. After the war he worked at the National Physical Laboratory, where he created one of the first designs for a stored-program computer, the ACE. In 1948 Turing joined Max Newman's Computing Laboratory at Manchester University, where he assisted in the development of the Manchester computers and became interested in mathematical biology. He wrote a paper on the chemical basis of morphogenesis, and predicted oscillating chemical reactions such as the Belousov-Zhabotinsky reaction, which were first observed in the 1960s. Turing's homosexuality resulted in a criminal prosecution in 1952, when homosexual acts were still illegal in the United Kingdom. He accepted treatment with female hormones (chemical castration) as an alternative to prison. Turing died in 1954, just over two weeks before his 42nd birthday, from cyanide poisoning. An inquest determined that his death was suicide; his mother and some others believed his death was accidental. On 10 September 2009, following an Internet campaign, British Prime Minister Gordon Brown made an official public apology on behalf of the British government for "the appalling way he was treated." As of May 2012 a private member's bill was before the House of Lords which would grant Turing a statutory pardon if enacted.
key = ASIMOV
```

详见[Vigenere维吉尼亚密码加解密及唯密文攻击](https://foopi.top/posts/314e2427/)。

通过一系列古典密码算法的亲手实现，深入理解了这几种古典密码的加解密过程。

## 实验二 基于公钥体制的加密和数字签名实现

### 实验内容

实现一个基于公钥算法的数字签名系统。以 RSA 为例，具体要求如下：

1. 能够对指定字符串（或其消息摘要）进行签名形成签名文，对签名文进行解密并与源字符串进行比对，验证其正确性；
2. 必须输出签名有关的各项参数：如公钥、私钥，通过乘积构成大整数的两个素数等；
3. 实现一个较完善的系统。

### 实验目的

目前，一般通过加密与解密、身份确认、数字签名等方法来保证信息存储与传输的安全。本实验的目的是使学生能够深入掌握公钥加解密算法、数字签名的基本原理，从而对密码学的公钥密码体制加解密、数字签名与身份认证、密钥管理等相关知识的系统应用有深入的理解。

### 实验原理

1976 年，美国学者 Diffie 和 Hellman 为解决信息公开传送和密钥管理问题，提出一种新的密钥交换协议，允许在不安全的媒体上的通讯双方交换信息，安全地达成一致的密钥，这就是“公开密钥系统”。相对于“对称加密算法”，这种方法也叫做“非对称加密算法”。与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥(publickey)和私有密钥 (privatekey)。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后发送给 甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。甲方只能用其专用密钥解密由其公用密钥加密后的任何信息。非对称加密算法的保密性比较好，它消除了最终用户交换密钥的需要，但加密和解密花费时间长、速度慢，不适合于对文件加密而只适用于对少量数据进行加密。

#### 公钥密码算法介绍

使用公开密钥对文件进行加密传输的实际过程包括四步:

1. 发送方生成一个自己的私有密钥并用接收方的公开密钥对自己的私有密钥进行加密，然后通过网络传输到接收方；
2. 发送方对需要传输的文件用自己的私有密钥进行加密，然后通过网络把加密后的文件传输到接收方；
3. 接收方用自己的公开密钥进行解密后得到发送方的私有密钥；
4. 接受方用发送方的私有密钥对文件进行解密得到文件的明文形式。 

因为只有接收方才拥有自己的公开密钥，所以即使其他人得到了经过加密的发送方的私有密钥，也因为无法进行解密而保证了私有密钥的安全性，从而也保证了传输文件的安全性。实际上，上述在文件传输过程中实现了两个加密解密过程：文件本身的加密和解密与私有密钥的加密解密，这分别通过私有密钥和公开密钥来实现。

#### 私钥数字签名技术

对文件进行加密只解决了传送信息的保密问题，而防止他人对传输的文件进行破坏，以及如何确定发信人的身份还需要采取其它的手段，这一手段就是数字签名。在电子商务安全保密系统中，数字签名技术有着特别重要的地位，在电子商务安全服务中的源鉴别、完整性服务、不可否认服务中，都要用到数字签名技术。在电子商务中，完善的数字签名应具备签字方不能抵赖、他人不能伪造、在公证人面前能够验证真伪的能力。

实现数字签名有很多方法，目前数字签名采用较多的是公钥加密技术，如基于 RSA Date Security 公司的 PKCS(Public Key Cryptography Standards)、Digital Signature Algorithm、 x.509、PGP(Pretty Good Privacy)。1994 年美国标准与技术协会公布了数字签名标准而使公钥加密技术广泛应用。公钥加密系统采用的是非对称加密算法。

目前的数字签名是建立在公共密钥体制基础上，它是公用密钥加密技术的另一类应用。 它的主要方式是，报文的发送方从报文文本中生成一个 128 位的散列值(或报文摘要)。发送方用自己的私人密钥对这个散列值进行加密来形成发送方的数字签名。然后，这个数字 签名将作为报文的附件和报文一起发送给报文的接收方。报文的接收方首先从接收到的原 始报文中计算出 128 位的散列值(或报文摘要)，接着再用发送方的公用密钥来对报文附加 的数字签名进行解密。如果两个散列值相同、那么接收方就能确认该数字签名是发送方的。 通过数字签名能够实现对原始报文的鉴别。

数字签名与书面文件签名有相同之处，采用数字签名，也能确认以下两点:第一，信 息是由签名者发送的;第二，信息自签发后到收到为止未曾作过任何修改。这样数字签名 就可用来防止电子信息因易被修改而有人作伪，或冒用别人名义发送信息。或发出(收到) 信件后又加以否认等情况发生。应用广泛的数字签名方法主要有三种，即:RSA 签名、DSS 签名和 Hash 签名。这三种算法可单独使用，也可综合在一起使用。数字签名是通过密码算 法对数据进行加、解密变换实现的，用 DES 算去、RSA 算法都可实现数字签名。但三种技 术或多或少都有缺陷，或者没有成熟的标准。

RSA 算法中数字签名技术实际上是通过一个哈希函数来实现的。数字签名的特点是它 代表了文件的特征，文件如果发生改变，数字签名的值也将发生变化。不同的文件将得到 不同的数字签名。一个最简单的哈希函数是把文件的二进制码相累加，取最后的若干位。 哈希函数对发送数据的双方都是公开的。 DSS 数字签名是由美国国家标准化研究院和国 家安全局共同开发的。由于它是由美国政府颁布实施的，主要用于与美国政府做生意的公 司，其他公司则较少使用，它只是一个签名系统，而且美国政府不提倡使用任何削弱政府

窃听能力的加密软件，认为这才符合美国的国家利益。Hash 签名是最主要的数字签名方法， 也称之为数字摘要法(Digital Digest)或数字指纹法(Digital Finger Print)。它与 RSA 数字 签名是单独的签名不同，该数字签名方法是将数字签名与要发送的信息紧密联系在一起， 它更适合于电子商务活动。将一个商务合同的个体内容与签名结合在一起，比合同和签名 分开传递，更增加了可信度和安全性。数字摘要(Digital Digest)加密方法亦称安全 Hash 编码法(SHA:Secure Hash Algorithm)或 MD5(MD Standard For Message Digest)，由 RonRivest 所设计。该编码法采用单向 Hash 函数将需加密的明文“摘要”成一串 128bit 的密 文，这一串密文亦称为数字指纹(Finger Print)，它有固定的长度，且不同的明文摘要必定 一致。这样这串摘要使可成为验证明文是否是“真身”的“指纹”了。

只有加入数字签名及验证才能真正实现在公开网络上的安全传输。加入数字签名和验证的文件传输过程如下:

(1)发送方首先用哈希函数从原文得到数字签名，然后采用公开密钥体系用发达方的 私有密钥对数字签名进行加密，并把加密后的数字签名附加在要发送的原文后面;

(2)发送一方选择一个秘密密钥对文件进行加密,并把加密后的文件通过网络传输到 接收方;

(3)发送方用接收方的公开密钥对密秘密钥进行加密,并通过网络把加密后的秘密密 钥传输到接收方;

(4)接受方使用自己的私有密钥对密钥信息进行解密，得到秘密密钥的明文; (5)接收方用秘密密钥对文件进行解密，得到经过加密的数字签名; (6)接收方用发送方的公开密钥对数字签名进行解密，得到数字签名的明文; (7)接收方用得到的明文和哈希函数重新计算数字签名，并与解密后的数字签名进行对比。如果两个数字签名是相同的，说明文件在传输过程中没有被破坏。





设计分析
 RSA 签名程序涉及很多个数学运算步骤，程序可以分成若干个模块。 1. 模加运算、模乘运算和模幂运算模块

(1) 模加运算“(a+b)%n”等价于“(a%n)+(b%n)%n”

(2) 模乘运算及计算两个数的乘积然后取模。为了避免大数相乘造成的溢出，根据 求模运算的性质，优化算法，其中

“(a*b)%n”等价于“(a%n)*(b%n)%n”
 (3) 模幂运算就是计算一个数的 n 次幂，然后进行取模运算。这里编程可以使用一

些数学技巧，另外同样要考虑避免大数相乘造成溢出的问题。(可参考教材

P121)

1. 素性测试算法:Solovay-Strassen素性测试算法、Miller-Rabin素性测试算法或其他检

   测方法

2. 大数的加法与减法运算

3. 求最大公约数

   ```
      求最大公约数可利用欧几里德的辗转相除法。
   ```

4. 随机数的产生(可参照教材 7 .2 节)

5. 计算私钥

6. 密钥的管理(可参照教材第7章)

7. 签名消息摘要的生成(可利用MD5、SHA-1算法或其他算法，参考教材第8章)

8. 签名与验证过程

**5.** 思考题
 1.查阅资料，了解一些其他的公钥密码体质，如 ElGamal 公约密码体制、Diffie-Hellman

密钥协商方案(基于求解离散对数的难解问题)、椭圆曲线密码体制(基于椭圆曲线离

散对数的难解问题)等，认识它们的基本原理和实现机制。 2.查阅资料，进一步了解其他签名方案如 DSA 算法，分析这些签名方案的基本原理和实

现机制等，以及它们与 RSA 的区别和联系。

### 实验步骤

### 实验总结



## 实验三 无线局域网安全实验

### 实验内容

完成无线局域网 WPA2-PSK 安全机制的配置以及 WPA2 的身份鉴别机制的应用。

### 实验目的

1. 验证 AP 和终端实现 WEP 安全机制相关参数的配置过程
2. 验证 AP 和终端实现 WPA2-PSK 安全机制相关参数的配置过程
3. 验证 终端 与 AP 之间建立关联的过程
4. 验证属于不同 BSS 的终端之间的通信过程
5. 验证 AAA 服务器的配置过程
6. 验证注册用户通过接入终端实现网络资源访问的过程

### 实验原理

随着移动终端的普及，无线局域网日益成为适用最广泛的局域网。无线局域网的无线传输特性，要求 AP 和 无线路由器必须对需要与其建立关联的终端进行身份鉴别，同时需要加密终端与 AP 和无线路由器之间传输的数据。因此，正确配置无线局域网的安全机制是安全使用无线局域网的前提。

#### WEP 和 WPA2-PSK 实验

![image-20210520092740982](https://img.foopi.top/postpic/image-20210520092740982.webp)

AP1 选择 WEP 安全机制，配置共享密钥。终端A 和 终端B 同样选择 WEP 安全机制，配置与 AP1 相同的共享密钥。AP2 选择 WPA2-PSK 安全机制，配置用于导出 PSK 的密钥。终端E 和 终端F 同样选择 WPA2-PSK 安全机制，配置与 AP2 相同的用于导出 PSK 的密钥。

Packet Tracer 中终端支持 Windows 的自动私有IP地址分配(Automatic Private IP Addressing, APIPA)机制，如果终端启动自动获得IP地址方式，但在发送DHCP请求消息后一直没有接受到DHCP服务器发送的响应消息，则Windows自动在微软保留的私有网络地址 169.254.0.0/255.255.0.0 中为终端随机选择一个有效IP地址。因此，如果扩展服务集中的所有终端均采用这一IP地址分配方式，则无须为终端配置IP地址就可实现终端之间的通信过程，安装无线网卡的终端的默认获取IP地址方式就是DHCP方式。

#### WPA2 实验

<img src="https://img.foopi.top/postpic/image-20210520125803728.webp" alt="image-20210520125803728" style="zoom:50%;" />

每一个用户完成注册后，获得唯一的身份标识信息：用户名和口令，所有注册用户的身份标识信息统一记录在AAA服务器中。每一台无线路由器中需要配置AAA服务器的IP地址和该无线路由器与AAA服务器之间的共享密钥。当无线路由器需要鉴别用户身份时，无线路由器只将用户提供的身份标识信息转发给AAA服务器，由AAA服务器完成身份鉴别过程，并将鉴别结果回送给无线路由器。

### 实验步骤

#### WEP 和 WPA2-PSK 实验

1. 根据如图5.1所示的无线局域网结构放置和连接设备：

   ![image-20210520100752011](https://img.foopi.top/postpic/image-20210520100752011.webp)

2. 默认情况下，笔记本计算机安装以太网卡，为了接入无线局域网，需要将笔记本计算机的以太网卡换成无线网卡。单击 Laptop0，弹出 Laptop0 配置界面，选择 Physical 配置选项，弹出安装物理模块界面。关掉主机电源，将原来安装在主机上的以太网卡拖放到左边模块栏中，然后将模块 WPC300N 拖放到主机原来安装以太网卡的位置。模块 WPC300N 是支持 2.4G 频段的 802.11、802.11b 和 802.11g 标准的无线网卡。重新打开主机电源。用同样的方式，将其他笔记本计算机的以太网卡换成无线网卡。

3. 完成 Access Point0 “Config”--“Port1” 操作过程。Authentication 中勾选 WEP，Encryption Type 选择 40/64-Bits(10 Hex digits)，在 WEP Key 框中输入由10个十六进制数字组成的40位密钥。在 SSID 框中输入制定的 SSID。Port Status 勾选 On。

   <img src="https://img.foopi.top/postpic/image-20210520101659620.webp" alt="image-20210520101659620" style="zoom: 50%;" />

4. 完成 Laptop0 “Config”--“Wireless0” 操作过程。在 Authentication 栏中选择 WEP，Encryption Type 选择 40/64-Bits(10 Hex digits)，在 WEP Key 框中输入与 Access Point0 相同的由10个十六进制数字组成的40位密钥。在 SSID 框中输入与 Access Point0 相同的 SSID。Port Status 勾选 On。以同样的方式完成 Laptop1 与实现 WEP 安全机制相关参数的配置过程。完成 Access Point0、Laptop0 和 Laptop1 与实现 WEP 安全机制相关参数的配置后，Laptop0 和 Laptop1 与 Access Point0 之间成功建立关联。

   <img src="https://img.foopi.top/postpic/image-20210520105846522.webp" alt="image-20210520105846522" style="zoom:50%;" />

5. 终端一旦选择 DHCP 方式，启动自动私有IP地址分配(APIPA)机制，在没有 DHCP服务器 为其配置网络信息的前提下，有终端自动在私有网络地址 169.254.0.0/255.255.0.0 中随机选择一个有效IP地址作为其IP地址。DHCP方式是安装无线网卡的笔记本计算机默认的获取网络信息方式。

6. 完成 Access Point1 “Config”--“Port1” 操作过程。Authentication 中勾选 WPA2-PSK，Encryption Type 选择 AES，导出 PSK 的 Pass Phrase 框中输入由8～63个字符组成的密钥。在 SSID 框中输入制定的 SSID。Port Status 勾选 On。

   <img src="https://img.foopi.top/postpic/image-20210520110700101.webp" alt="image-20210520110700101" style="zoom:50%;" />

7. 完成 Laptop2 “Config”--“Wireless0” 操作过程。在 Authentication 栏中选择 WPA2-PSK，Encryption Type 选择 AES，在导出 PSK 的 Pass Phrase 框中输入与 Access Point1 相同的由8～63个字符组成的密钥。在 SSID 框中输入与 Access Point1 相同的 SSID。Port Status 勾选 On。以同样的方式完成 Laptop3 与实现 WPA2-PSK 安全机制相关参数的配置过程。完成 Access Point1、Laptop2 和 Laptop3 与实现 WEP 安全机制相关参数的配置后，Laptop2 和 Laptop3 与 Access Point1 之间成功建立关联。

   <img src="https://img.foopi.top/postpic/image-20210520110739168.webp" alt="image-20210520110739168" style="zoom:50%;" />

8.  完成 PC0 “Desktop”--“IP Configuration” 操作过程。选择 DHCP，由 PC0 自动选择的IP地址如图所示。以同样的方式完成 PC1 获取网络信息过程。

   <img src="https://img.foopi.top/postpic/image-20210520111126682.webp" alt="image-20210520111126682" style="zoom:50%;" />

9. 通过简单报文工具启动各个终端之间的 ICMP 报文传输过程，验证各个终端之间的连通性。

   <img src="https://img.foopi.top/postpic/image-20210520113354089.webp" alt="image-20210520113354089" style="zoom:50%;" />

   Laptop0的IP地址信息:

   <img src="https://img.foopi.top/postpic/image-20210520113457302.webp" alt="image-20210520113457302" style="zoom:50%;" />

   ping Laptop1:

   <img src="https://img.foopi.top/postpic/image-20210520113807468.webp" alt="image-20210520113807468" style="zoom:50%;" />

   ping Laptop3:

   <img src="https://img.foopi.top/postpic/image-20210520113926688.webp" alt="image-20210520113926688" style="zoom:50%;" />

   ping PC1:

   <img src="https://img.foopi.top/postpic/image-20210520114039489.webp" alt="image-20210520114039489" style="zoom:50%;" />

#### WPA2 实验

1. 无线局域网中，终端与无线路由器之间没有物理连接过程，但终端必须位于无线路由器的有效通信范围内，因此，无线局域网需要在物理工作区中确定终端与无线路由器之间的距离。选择物理工作区，单击 NAVIGATION 菜单，选择 Home City，单击 Jump to Selected Location 按钮，物理工作区中出现家园城市界面。

   <img src="https://img.foopi.top/postpic/image-20210520131302882.webp" alt="image-20210520131302882" style="zoom:50%;" />

2. 在设备类型选择框中选择 Wireless Devices，在设备选择框中选择无线路由器(WRT300N)。将无线路由器拖放到物理工作区中，可以看到无线路由器的有效通信范围。将笔记本计算机放置在无线路由器的有效通信范围内，无线设备选择无线路由器而不是 AP 的原因是 Packet Tracer 中只有无线路由器支持 WPA2。在物理工作区中根据如图5.10所示的无线局域网结构放置和连接设备。

   <img src="https://img.foopi.top/postpic/image-20210520133425074.webp" alt="image-20210520133425074" style="zoom:50%;" />

3. 切换到逻辑工作区。

   <img src="https://img.foopi.top/postpic/image-20210520133524128.webp" alt="image-20210520133524128" style="zoom:50%;" />

4. 完成无线路由器 Router1 “Config”--“Wireless” 操作过程。在 Authentication 栏中选择 WPA2。在 RADIUS Server Settings 栏下的 IP Address 框中输入 RADIUS服务器 的IP地址，这里是 192.1.2.7。 在 Shared Secret 框中输入该无线路由器与 AAA服务器 之间的共享密钥，这里是 router1。Encryption Type 选择 AES。在 SSID 框中输入指定的 SSID，这里是 123456。以同样的方式完成无线路由器 Router2 无线接口配置过程。

   <img src="https://img.foopi.top/postpic/image-20210520134120206.webp" alt="image-20210520134120206" style="zoom:50%;" />

5. 完成无线路由器 Router1 “Config”--“Internet” 操作过程。在 IP Configuration 栏中选择 Static IP 地址配置方式。在 Default Gateway 框中输入路由器 Router 连接交换机 Switch0 的接口的IP地址，这里是192.1.1.254。在 IP Address 框中输入无线路由器 Router1 Internet 接口的IP地址，这里是 192.1.1.1。在 Subnet Mask 框中输入无线路由器 Router1 Internet 接口的子网掩码，这里是 255.255.255.0。以同样的方式完成无线路由器 Router2 Internet 接口配置过程。

   <img src="https://img.foopi.top/postpic/image-20210520135005012.webp" alt="image-20210520135005012" style="zoom:50%;" />

6. 完成 AAA Server “Desktop”--“IP Configuration” 操作过程。配置的IP地址必须与无线路由器 Router1、Router2 中配置的 RADIUS 服务器地址相同。

   <img src="https://img.foopi.top/postpic/image-20210520143830735.webp" alt="image-20210520143830735" style="zoom:50%;" />

7. 完成 AAA Server ”Services“--”AAA“ 操作过程。首先建立与路由器 Router1 和 Router2 之间的关联。建立关联过程中，在 Client Name 框中输入设备标识符，如无线路由器 Router2 的设备标识符 Router2。在客户端 Client IP 框中输入无线路由器 Router1 和 Router2 向 AAA 服务器发送 RADIUS 报文时，用于输出 RADIUS 报文的接口的IP地址，即 Router1 和 Router2 Internet 接口的IP地址，如无线路由器 Router2 Internet 接口的IP地址 192.1.1.2。在 Secret 框中输入 Router1 和 Router2 与 AAA 服务器之间的共享密钥，如 Router2 与 AAA 服务器之间的共享密钥 router2。

   然后定义所有的注册用户。定义注册用户过程中，在 Username 框中输入注册用户的用户名，如 aaa3。在 Password 框中输入注册用户的口令，如 bbb3。

   <img src="https://img.foopi.top/postpic/image-20210520140455116.webp" alt="image-20210520140455116" style="zoom:50%;" />

8. 配置路由器 Router

   <img src="https://img.foopi.top/postpic/image-20210520141939831.webp" alt="image-20210520141939831" style="zoom:50%;" />

   <img src="https://img.foopi.top/postpic/image-20210520142011895.webp" alt="image-20210520142011895" style="zoom:50%;" />

9. 完成 Laptop0 "Config"--"Wireless0" 操作过程。

   <img src="https://img.foopi.top/postpic/image-20210520143951470.webp" alt="image-20210520143951470" style="zoom:50%;" />

   <img src="https://img.foopi.top/postpic/image-20210520144308161.webp" alt="image-20210520144308161" style="zoom:50%;" />

10. 通过简单报文工具，验证 Laptop* 与 Web服务器之间的连通性。

    ![image-20210520145058291](https://img.foopi.top/postpic/image-20210520145058291.webp)

### 实验总结





## 实验四 点对点IP隧道实验

### 实验内容

完成点对点IP隧道网络搭建，利用IP隧道技术完成一对用户通过公共网络进行安全通信的过程。

### 实验目的

1. 掌握VPN设计过程
2. 掌握点对点IP隧道配置过程
3. 掌握公共网络路由建立过程
4. 掌握内部网络路由建立过程
5. 验证公共网络隧道两端的传输路径的建立过程
6. 验证基于隧道实现的内部子网之间的IP分组传输过程

### 实验原理

<img src="https://img.foopi.top/postpic/image-20210520150008317.webp" alt="image-20210520150008317" style="zoom:50%;" />

VPN 物理结构如图(a)所示。路由器 R4、R5 和 R6 构成公共网络，边缘路由器 R1、R2 和 R3 一端连接内部子网，另一端连接公共网络。由于公共网络无法传输以私有IP地址为源和目的IP地址的IP分组，因此，由公共网络互连的多个分配私有IP地址的内部子网之间无法直接进行通信。为了实现被公共网络分隔的多个内部子网之间的通信过程，需要建立以边缘路由器连接公共网络的接口为两端的点对点IP隧道，并为点对点IP隧道的两端分配私有IP地址。因此将(a)所示的物理结构转变为(b)所示的逻辑结构:

<img src="https://img.foopi.top/postpic/image-20210520150836542.webp" alt="image-20210520150836542" style="zoom:50%;" />

点对点IP隧道成为互连边缘路由器的虚拟点对点链路，边缘路由器之间能够通过点对点IP隧道直接传输以私有IP地址为源和目的IP地址的IP分组。点对点IP隧道经过公共网络，因此需要通过隧道技术完成以私有IP地址为源和目的IP地址的IP分组经过公共网络传输的过程。

### 实验步骤

1. 根据图(a)所示网络结构放置和连接设备。
2. 
3. 
4. 
5. 

### 实验总结







## 实验

### 实验内容

### 实验目的

### 实验原理

### 实验步骤

### 实验总结